/*
 * OuterLoop.c
 *
 *  Created on: Apr 30, 2013
 *      Author: Daniel
 */

#include "Functions.h"
extern POSSPEED qep_posspeed;

#define absOffset  0.72444384;

Uint16 Abs_Enc[3] = {0};

short int arrayPos = 0;
Uint16 tita = 0;
titaFactors[4] = {1,3,-3,-1};

interrupt void Outer_Loop(void)
{
	long int temp = 0;
	double tita = 0;
	EPwm2Regs.ETCLR.bit.INT = 1;							//Clear Interrupt in timer
	//Read data from absolute encoder
	GpioG1DataRegs.GPADAT.bit.GPIO6 = 0; 					//Latch Output
	temp = (GpioG1DataRegs.GPADAT.all & 0x000FFF00) >> 8;
	GpioG1DataRegs.GPADAT.bit.GPIO6 = 1; 					//UnLatch Output
	tita = (temp*2*PI/4096);
	tita += absOffset;

	if(tita > (2*PI))
	{ tita = tita-(2*PI); }
	else if(tita < 0)
	{ tita = tita + (2*PI);	}

	//Generating continuous value for tita
	if(((tita>=0 && tita<=PI/2)&&(tita_prev>=3*PI/2 && tita_prev<=2*PI)) ||
	   ((tita_prev>=0 && tita_prev<=PI/2)&&(tita>=3*PI/2 && tita<=2*PI)))
	{
		rev = rev - sign(tita-tita_prev);
	}

	if(tita >= PI)						//tita_neg for stabilizing(inverted position zero)
	{	tita_neg = tita-2*PI;	}
	else
	{	tita_neg = tita;		}

	if(tita_neg >= 0 && tita_neg <= PI)
	{	theta=tita_neg-PI;		}
	else
	{	theta = tita_neg + PI;	}

	tita_cont = tita+(2*PI*rev);

	//Evaluating derivatives using finite difference equations and past samples

	titadot = (tita_cont + 3*tita_hist[0] - 3*tita_hist[1] -tita_hist[2])/(6*SAMP_PER);




	//Read data from relative encoder
	qep_posspeed.calc(&qep_posspeed);

	//Calculate algorithm

	//output PWM

	 PieCtrlRegs.PIEACK.all = PIEACK_GROUP3; // Acknowledge interrupt to PIE
	 return;

}

short int sign(double x)
{
	if(x>0)
	{ return 1; }
	else if(x<0)
	{ return -1; }
	else
	{ return 0; }
}


